---
title: "컨테이너와 도커"
date: 2026-02-09 12:00:00 +0900
categories: [blog]
layout: single
---

## 컨테이너란?

가상머신(VM)과 컨테이너의 차이점

`VM`

- Host OS에서 구동되는 하드웨어에 가상으로 액세스하는 Guset OS를 가지는 격리된 머신.
- 가상의 하나의 컴퓨터 ⇒ 실제 물리 하드웨어를 에뮬레이트 하므로 OS가 반드시 필요
- OS가 가상머신 이미지에 포함되어야 하기 때문에 용량이 크고 성능 효율성이 떨어짐

`컨테이너`

- 가상머신과 마찬가지로 관련 라이브러리 및 모든 종속항목과 패키지를 묶어 격리환경을 마련하나, VM과 다르게 별도의 하드웨어 애뮬레이션 없이 리눅스 커널을 공유 → Guset OS 필요 X → 운영체제 수준의 가상화
- 리눅스 컨테이너를 통해 프로세스 격리가 가능하다

> 리눅스에서 커널 공간과 유저공간이 나눠져있고 이중 사용자 공간을 여러개로 나눠서 프로세스에서 사용하는 리소스를 제한할 수 있는데, 이가 바로 컨테이너의 근간이 되는 기술이다.
> 

리눅스 권한 레벨

| 구분 | 이름 | 할 수 있는 것 |
| --- | --- | --- |
| Ring 0 | Kernel mode | 하드웨어 직접 제어 |
| Ring 3 | User mode | 제한된 명령만 가능 |

커널공간(Kernel space)

- OS 핵심 코드가 실행되는 영역
- Linux kernel 자체, 프로세스 스케쥴러, 메모리 관리자, 파일 시스템, 네트워크 스텍, 디바이스 드라이버
- 절대권한. 유저 프로그램은 직접 접근 불가

유저공간(User space)

- 우리가 실행하는 모든 프로그램이 존재하는 공간
- bash, zsh, nginx, php-fpm, node 등등
- 권한제어, 실수해도 해당 프로세스만 죽음

Namespace

- 유저공간은 논리적으로 나뉜다.
    
    리눅스의 프로세스는 자기만의 PID공간, 파일 시스템 뷰, 네트워크 스택, 유저/그룹을 가지고 있고 이를 Namespace라고 함.
    
    (pid(프로세스), mount(파일시스템), net(네트워크), uts(hostname), ipc(ipc자원), user(uid/gid) USER분리는 옵션)
    
- 각 프로세스가 파일시스템, 네트워크, 유저, 호스크네임 등에 대해서 시스템이 독립뷰를 가질 수 있도록 만들어줌

리소스 제한 ⇒ cgroup

- CPU 최대 사용량, 메모리상한, 디스크 I/O제한 할 수 있는 기능으로,
각각의 프로세스에 리소스를 할당할 수 있음
- 컨테이너는 리눅스가 제공하는 기능을 이용하여 단절된 공간에서 할당받은 시스템 자원을 통해 독립적으로 가동되는 일종의 프로세스

**컨테이너 = ?**

Linux Kernel
├─ nginx(host)   (PID ns #1, NET ns #1) — 기본 namespace
├─ mysql(host)   (PID ns #1, NET ns #1)
├─ bash(host)    (PID ns #1, NET ns #1)
│
├─ container-A-app (PID ns #2, NET ns #2) — Namespace + cgroup으로 쪼개진 공간, 제한된 자원
└─ container-B-app (PID ns #3, NET ns #3)

장점

* 빠른 속도화 효율성

    * 하드웨어 에뮬레이션이 없으므로 컨테이너는 아주 빠른 속도로 실행됨
    * 컨테이너 생성이라는 건 OS 입장에서 프로세스를 시작하는 것과 같음
    * 새로운 커널 시작도, 하드웨어 초기화 작업도 필요없음

* 집적도
    * 컨테이너는 커널이 직접 조작하여 공간을 분리하기 때문에 OS는 하나만 존재.
    * 여러개의 컨테이너를 만들어 실행하여도 하나의 OS위에서 돌아가기 때문에 프로세스를 여러개 실행하는 것 처럼 많이 실행할 수 있음. VM에 비해 고밀도가 가능

* 높은 이식성
    * 모든 컨테이너는 호스트의 환경이 아닌 독자적인 실행환경을 가지고 있고, 이를 이미지 형식으로 공유할 수 있음
    * 리눅스 커널을 사용하고 같은 컨테이너 런타임을 사용할 경우 컨테이너 실행 환경을 쉽게 공유하고 재현 가능
* 애플리케이션 컨테이너 자원
    => 컨테이너 - 시스템 컨테이너, 애플리케이션 컨테이너로 나뉨

    
    * 시스템 컨테이너 ⇒ OS처럼 쓰는 컨테이너 (eg. LXC/ LXD)
        ```
        Host Kernel
        └─ System Container
        ├─ init/systemd
        ├─ sshd
        ├─ cron
        ├─ network service
        └─ 여러 앱
        ```
        VM느낌과 가까우나 커널은 여전히 Host 커널을 공유


    * 애플리케이션 컨테이너
    ⇒ 하나의 애플리케이션 실행목적(eg. nginx컨테이너, node 컨테이너, php-fpm 컨테이너)
        - 단 하나의 프로세스만 실행한다는 점에서 확장이 쉽고 관리가 용이
        - 대표적인 애플리케이션 컨테이너의 런타임은 도커
        - 목적에 맞는 프로세스만 존재하는 환경을 만들 수 있음
        - 기존 서버 운영방식에서는 애플리케이션 실행을 위해 서버 컴퓨터의 상태를 지속적으로 관리해야 했지만, 독립적인 환경을 구축하고 관리하는 것이 가능해졌기 때문에 서버 환경의 관리가 용이해 졌음
            ```
            Host Kernel
            └─ Container
            └─ nginx process
            ```

## 도커란?

* 컨테이너 기술을 지원하는 다양한 프로젝트 중 하나
* 업계표준
* 오버레이 네트워크, 유니온 파일시스템 등 이미 존재하고 있는 기술들을 정교하게 잘 조합하여 사용자 입장에서 사용하기 편리하게 만들어 놓음

`도커 이미지`
* 컨테이너라는 개념과 더불어 도커에서 중요한 개념이 바로 이미지
* 이미지란 컨테이너 실행에 필요한 모든 파일과 설정 값 등를 포함한 것으로 상태값을 가지고 변하지 않는 것

    >특정 프로세스를 실행하기 위한 파일, 설정 값 등을 지닌 것으로 더 이상 의존성 파일을 컴파일하거나 설치할 필요가 없음
    >

`레이저 저장방식`

* 도커는 유니온 파일 시스템을 이용하여 여러개의 layer를 하나의 파일 시스템으로 만드는 방식을 사용.

* 이미지는 여러개의 immutable(불변) layer로 구성.

    => 예를 들어 우분투 이미지가 이미 있는 상태에서 우분투 기반의 nginx이미지를 도커허브에서 가져온다면, 이미 존재하는 우분투 레이어는 다운로드 받지 않고 nginx 레이어만 다운로드 받아 새로운 이미지를 구성

    Dockerfile:


        ```docker
        FROM ubuntu:22.04
        RUN apt install nginx
        COPY app /app
        ```

    ⇒ 이걸 합쳐서 하나의 이미지처럼 보임

이미지 기반으로 컨테이너를 생성하면 자동의 r/w 레이어가 추가되어 생성되는데,컨테이너 실행 중 생성하는 파일이나 변경사항은 모두 r/w레이어에 기록됨. 기존의 이미지 레이어에는 영향을 주지 않음



출처: [kt cloud 기술 블로그] https://tech.ktcloud.com/entry/도커Docker를-공부하는-초보자를-위한-안내서-ch-3-도커-이미지